
#include"book_management.h"
#include "user.h"
extern char librarian_account[];
extern account logger;
pbook bookhead = NULL;//创建头指针，初始值为NULL
int n = 0;
//saves the database of books in the specified file
//returns 0 if books were stored correctly, or an error code otherwise
int store_books() 
{
	FILE *file;
	int a;
	pbook sbook = bookhead ;
	file=fopen("bookfile","w+");   //以读写方式打开名字为bookfile的二进制文件，同时清空文件原本内容 
	if(file==NULL)
	{
		printf("can not open the file");
		return 1; 
	}
	if (sbook==NULL){
		return 1;//链表还为空，没有书籍需要存入文件 
	}
	while(sbook!=NULL){ 
		a=fwrite(sbook,sizeof(struct _Book),1,file);//将链表中的内容内容存入file所指向的文件中
		if(a!=1)   
		{
			printf("An error occurred while writing to the file");
			return 1;
		}
		sbook = sbook->nextbook; 	
	}
	fclose(file);    //关闭文件
	return 0;	
} 


//loads the database of books from the specified file
//the file must have been generated by a previous call to store_books()
//returns 0 if books were loaded correctly, or an error code otherwise
int load_books()
{ 
	FILE *file;
	file=fopen("bookfile","ab+");  //打开文件
	pbook bookpa = NULL, bookpb = NULL, bookpc = NULL;
	if(file==NULL)
	{
		printf("can not open the file");
		return 1;
	}
	while(!feof(file))        //判断读写标志是否移到文件末尾 
	{
	   bookpa=(pbook)malloc(sizeof(Book)); //用malloc在内存申请一段空间 
	   fread(bookpa,sizeof(struct _Book),1,file);     //将file所指向文件的内容传递给bookpa 
	   if(bookhead==NULL)
	   {
	      bookhead=bookpa;
	      bookpb=bookpa;
	    }
	    else             //建立链表 
	    {
	    	bookpc=bookpb;
	    	bookpb->nextbook=bookpa;
	    	bookpb=bookpa;
		}
    }
    if(bookpc!=NULL)
	{  	//文件里没有数据 
       bookpc->nextbook=NULL;
   	}
    else
    {
	   bookhead=NULL;
	}
	fclose(file);    //关闭文件
	return 0; 
}


//adds a book to the ones available to the library
//returns 0 if the book could be added, or an error code otherwise
int add_book(Book book)
{
	do
	{
		pbook padd , bookpr = bookhead, bookid = bookhead;
		unsigned int ids;
		FILE *afile;
		FILE *file;    //指向文件的指针 
		int f;
		char s;
		padd=(pbook)malloc(sizeof(Book));//申请内存空间
		if(padd == NULL){			//如果申请内存失败，则添加book失败，返回1 
			printf("memory allocation failed\n");
			return 1;
		}
		if(bookhead == NULL){ //如果头指针是NULL,说明可以从头添加节点 
			bookhead = padd;
		}
		else
		{
			while(bookpr->nextbook!= NULL){
					bookpr = bookpr->nextbook;
			}
			bookpr->nextbook = padd;
		}
		//添加图书信息
		do
		{
			printf("\nPlease input BOOK id(can not be 0!) ");    
			scanf("%u",&padd->id);
			while(bookid!=NULL)
			{
				ids=padd->id;
				if(bookid->id!=ids)
				{
					padd->id=0;
					printf("\n请重新输入，此ID已存在");
//					printf("%u\n",padd->id);
					printf("%u\n",bookid->id);
//					printf("%u\n",bookhead->id);
					printf("%u\n",ids); 
					break; 
				}
				bookid=bookid->nextbook;
			}
		}while(padd->id==0);
		printf("\nPlease input BOOK title ");
		scanf("%s",&padd->title);
		printf("%u",bookhead->id);
		printf("\nPlease input BOOK authors ");
		scanf("%s",&padd->authors);
		printf("\nPlease input Year of publication ");
		scanf("%u",&padd->year);
		printf("\nPlease input the number of copies of the book ");
		scanf("%u",&padd->copies);
		padd->nextbook = NULL;//新增的节点位于链表末端，所以为null 
		system("pause");
		free(padd);
		printf("\n|                                              |");
		printf("\n| Saved successfully. Do you want to continue  |");
		printf("\n| 1.YES                                    2.NO|\n"); 
		s=getch();
		do{
			if(s=='1')
			{
				break;
			}	 
			else if(s=='2')
			{
				return 0;
			}			
		 }while(1);  
	}while(1);
}

//removes a book from the library
//returns 0 if the book could be successfully removed, or an error code otherwise.
int remove_book(Book book){
	do
	{
		system("cls");
		FILE *file1;
		FILE *afile;
		int aj=0,ax,ai=11,tt,uu;
		char title[20];
		char at,ac;
		int ach,iD; 
		pbook premove = NULL , preremove = NULL, p1 = NULL, p2 = NULL;
		premove = bookhead;
		setxy(50,9);
		printf("\n请输入你要删除的图书的书名：");
		scanf("%s",title);
		setxy(19,6);
		printf("**********************图书信息******************************");
		setxy(19,9);
		printf("------------------------------------------------------------");
		setxy(19,10);
		printf(" ID        Title        authors         years        copies ");
		setxy(19,11);
		printf("------------------------------------------------------------");
		while(premove!=NULL)
		{
			if(premove!=NULL&&strcmp(premove->title,title)==0)//strcmp用于检验字符串是否相同 
			{
				setxy(20,ai);
				aj++;
				printf("%d:%u%20s%20s%u   %u   \n",aj,premove->id,premove->title,premove->authors,premove->year,premove->copies);
				ai++;
			}
			premove=premove->nextbook;
		}
		if(aj==0)                   //如果aj=0，说明没有进入前面的循环，也就是相应的信息没有被找到 
		{ 
			setxy(50,ai);
			printf("\n没有找到相应的信息！(按0返回，按1重新搜索)");
			while(1)               //用死循环防止除0和1的其他按键干扰 
			{
				scanf("%d",&ach);
				if(ach==0)
				{
					Mainmenu();
					break;
				}
				else if(ach==1)
				{
					break;
				}
			}
			if(ach==1)     //如果输入的ach等于1，结束本次循环 
			   continue;
		}
		while(1)
		{
			setxy(46,ai);
			printf("\n请输入您要删除的图书的ID：");
			scanf("%d",&iD);
			p1=bookhead;
			while(1)
			{
				
				if(p1->id==iD&&strcmp(premove->title,title)==0){
					break;
				}
				else{
					p1=p1->nextbook;
				}
				if(p1==NULL){
					setxy(46,++ai);
					printf("Input error, please input again!");//输入有错误，提醒用户重新输入
					break;
				}
			}
		}
		setxy(47,9);
		printf("-------------------------");
		setxy(47,10);
		printf("|                       |");
		setxy(47,11);
		printf("|     是否确认删除？    |");
		setxy(47,13);
		printf("| 1.是             2.否 |");
		setxy(47,14);
		printf("|                       |");
		setxy(47,15);
		printf("-------------------------");
		while(1)
		{
			scanf("%d",&tt);
			if(tt==1)
			{
				break;
			} 
			else if(tt==2)
			{
				return 1;
			}
		} 
		premove=bookhead;
		while(premove!=NULL&&premove->id!=iD)
		{
			preremove=premove;
			premove=premove->nextbook;
		}
		if(premove!=NULL)
		{
			if(preremove==NULL)
			{
				bookhead=bookhead->nextbook;
			}
			else
			{
				preremove->nextbook=premove->nextbook;
			}
		}
		free(premove);
		store_books();
		load_books();
		system("cls");
		setxy(47,8);
		printf("-------------------------");
		setxy(47,9);
		printf("|                       |");
		setxy(47,10);
		printf("|  删除成功，是否继续？ |");
		setxy(47,12);
		printf("| 1.是             2.否 |");
		setxy(47,13);
		printf("|                       |");
		setxy(47,14);
		printf("-------------------------");
		while(1)
		{
			scanf("%d",&uu);
			if(uu==1)
			{
				break;
			}
			else if(uu==2)
			{
				return 0;
			}
		}
	}while(1);
} 

//the module of finding book
void search_book()  //查询图书 
{
	do
	{
		const char *title;
		const char *author;
		unsigned int year;
		system("cls");  //清屏 
		printf("\t\t 图书查询\n\n");

		printf("\t\t|     1.书名  查询      |\n\n");

		printf("\t\t|     2.作者  查询      |\n\n");

		printf("\t\t|     3.ID    查询      |\n\n");

		printf("\t\t|     4.年份  查询      |\n\n");

		printf("\t\t|     5.返回上一级      |\n\n");

		printf("\t\t|     0.返回主菜单      |\n\n");
		int i =6;
		scanf("%d",&i);
		switch(i)
		{
			case 0:Mainmenu();
			break;
			case 1:find_book_by_title (title);
			break;
			case 2:find_book_by_author(author);
			break;
			case 3:find_book_by_ID ();
			break;
			case 4:find_book_by_year (year);
			break;
			case 5:
			if(logger!=NULL&&strcmp(logger->register_account,librarian_account)==0)
			{
				administrator_menu();
			}
			else if(logger!=NULL)
			{
				user_menu();
			}
			else{
				Mainmenu();
			} 
			default :break;
		 } 
	}while(1);
}

//修改书目
int amend_book()
{
	system("cls");
	int y=0;
	FILE *afile;
	unsigned int digit = 0;
	char *amend;  
	pbook book_head,pfind;
	book_head = bookhead;
	BookArray parray;
	unsigned int iD;
	printf("请输入您要修改的图书的ID：\n");
	scanf("%u", &iD); 
	printf("正在查询....\n");
	pfind=book_head;
	printf("**************************图书总览*****************************\n");
	printf("---------------------------------------------------------------\n");
	printf("登录号        书名        作者名         出版时间          数量\n");
	printf("---------------------------------------------------------------\n");
	while(pfind!=NULL)
	{
		if(pfind!=NULL&&pfind->id==iD)
		{
			printf("%d%14s%14s         %.2f%12d\n",pfind->id,pfind->title,pfind->authors,pfind->year,pfind->copies);
			y=1;
			break;
		}
		pfind=pfind->nextbook;
	}
	if(y==0)
	{
		printf("\n未找到对应书目");
		system("pause");
		return 0; 
	}
	else
	{
		int st = 0;
		printf("\n-------------------------");
		printf("\n|                       |");
		printf("\n|     是否确认修改？    |");
		printf("\n| 1.是             2.否 |");
		printf("\n|                       |");
		printf("\n-------------------------");
		while(1)
		{
			scanf("%d",&st);
			if(st==1)
			{
				break;
			} 
			else if(st==2)
			{
				return 1;
			}
		}
		printf("请修改图书登录号");
		scanf("%u",&digit);
		getchar();
		pfind->id=digit;
		printf("请修改书名");
		scanf("%s",amend);
		getchar();
		strcpy(pfind->title,amend);
		printf("请修改作者名");
		scanf("%s",amend);
		getchar();
		strcpy(pfind->authors,amend);
		printf("请修改图书出版时间");
		scanf("%u",&digit);
		getchar();
		pfind->year=digit;
		printf("请修改图书数量");
		scanf("%u",&digit);
		getchar();
		pfind->copies=digit;
		printf("修改成功");
		store_books();
		load_books();		
		system("pause");
		return 0;
	}	
} 

 

//finds books with a given title.
//returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the 
//provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
//array is the null pointer.
BookArray find_book_by_title (const char *title)
{
	system("cls");
	int y=0; 
	pbook book_head,pfind;
	book_head = bookhead;
	BookArray parray;
	char atitle[20];
	printf("请输入您要查询图书的书名：\n");
	scanf("%s", atitle); 
	printf("正在查询....\n");
	pfind=book_head;
	printf("**************************图书总览*****************************\n");
	printf("---------------------------------------------------------------\n");
	printf("登录号        书名        作者名         出版时间          数量\n");
	printf("---------------------------------------------------------------\n");
	while(pfind!=NULL)
	{
		if(pfind!=NULL&&strcmp(pfind->title,atitle)==0)
		{
			printf("%d%14s%14s         %.2f%12d\n",pfind->id,pfind->title,pfind->authors,pfind->year,pfind->copies);
			y=1;
		}
		pfind=pfind->nextbook;
	}
	if(y==0)
	{
		printf("\n未找到对应书目\n");
	}
	system("pause");
	search_book();
	return parray;
} 


//finds books with the given authors.
//returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the 
//provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
//array is the null pointer.
BookArray find_book_by_author(const char *author)
{
	system("cls");
	int y=0; 
	pbook book_head,pfind;
	book_head = bookhead;
	BookArray parray;
	char authors[20];
	printf("请输入您要查询图书的作者：\n");
	scanf("%s", authors); 
	printf("正在查询....\n");
	pfind=book_head;
	printf("**************************图书总览*****************************\n");
	printf("---------------------------------------------------------------\n");
	printf("登录号        书名        作者名         出版时间          数量\n");
	printf("---------------------------------------------------------------\n");
	while(pfind!=NULL)
	{
		if(pfind!=NULL&&strcmp(pfind->authors,authors)==0)
		{
			printf("%d%14s%14s         %.2f%12d\n",pfind->id,pfind->title,pfind->authors,pfind->year,pfind->copies);
			y=1;
		}
		pfind=pfind->nextbook;
	}
	if(y==0)
	{
		printf("\n未找到对应书目\n");
	}
	system("pause");
	search_book();
	return parray;

}

//finds books published in the given year.
//returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the 
//provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
//array is the null pointer.
BookArray find_book_by_year (unsigned int year){
	system("cls");
	int y=0; 
	pbook book_head,pfind;
	book_head = bookhead;
	BookArray parray;
	unsigned int time;
	printf("请输入您要查询图书的年份：\n");
	scanf("%u", &time); 
	printf("正在查询....\n");
	pfind=book_head;
	printf("**************************图书总览*****************************\n");
	printf("---------------------------------------------------------------\n");
	printf("登录号        书名        作者名         出版时间          数量\n");
	printf("---------------------------------------------------------------\n");
	while(pfind!=NULL)
	{
		if(pfind!=NULL&&pfind->year==time)
		{
			printf("%d%14s%14s         %.2f%12d\n",pfind->id,pfind->title,pfind->authors,pfind->year,pfind->copies);
			y=1;
		}
		pfind=pfind->nextbook;
	}
	if(y==0)
	{
		printf("\n未找到对应书目\n");
	}
	system("pause");
	search_book();
	return parray;	
} 
//finds books published in the given ID.
void find_book_by_ID ()
{
	system("cls");
	int y=0; 
	pbook book_head,pfind;
	book_head = bookhead;
	unsigned int iD;
	printf("请输入您要查询图书的ID：\n");
	scanf("%u", &iD); 
	printf("正在查询....\n");
	pfind=book_head;
	printf("**************************图书总览*****************************\n");
	printf("---------------------------------------------------------------\n");
	printf("登录号        书名        作者名         出版时间          数量\n");
	printf("---------------------------------------------------------------\n");
	while(pfind!=NULL)
	{
		if(pfind!=NULL&&pfind->id==iD)
		{
			printf("%d%14s%14s         %.2f%12d\n",pfind->id,pfind->title,pfind->authors,pfind->year,pfind->copies);
			y=1;
		}
		pfind=pfind->nextbook;
	}
	if(y==0)
	{
		printf("\n未找到对应书目\n");
	}
	system("pause");
	search_book();	
} 

